[{"categories":["database"],"content":"mongodb 数据自动过期 使用 pymongo 和 mongo index # 在python中insert时带上expire_time doc = { '_id': ObjectId(), ... 'expire_time': datetime.datetime.utcnow() } # 在collection中添加 index, 并带有过期属性, 单位为s db.collection.createIndex({\"expire_time\": 1}, {expireAfterSeconds: NumberInt(\"691200\")}); mongo 会有一个专门的进程扫描带有expire_time字段的数据, 通过对比里面的时间, 判断数据是否需要清除. 更改某字段为另外一个字段的值 db.info.find().forEach( function(item){ db.info.update({\"_id\":item._id},{\"$set\": {\"symbol_dsp\":item.symbol}}) } ) 更改某字段, 对字段做一些处理 db.symbol_info.find({'exchange': 'cococoin', 'symbol_type': 1}).forEach( function(item){ item.rest_symbol = item.rest_symbol.replace(\"661.\", \"\") db.symbol_info.update({\"_id\":item._id},{\"$set\": {\"rest_symbol\":item.rest_symbol}}) } ) 跨表修改字段的值 db.coin_mapping.find({\"status\":1}).forEach( function(x){ db.info.update({'_id': x.mars_coin_id}, {$set: {'qkl123_id': NumberInt(x.qkl123_coin_id)}}) } ) 查重 db.duplicate_coin.aggregate([ { $group: { _id : '$symbol', count: { $sum : 1 } } }, { $match: { count: { $gt : 1} } } ]) ## 多字段批量查询 db.symbol_info.aggregate([ { $group: { _id : {symbol: '$symbol', ex: '$exchange', status: '$status'}, count: { $sum : 1 } } }, { $match: { count: { $gt : 1} } } ]) 字段类型 ## 查看字段类型 db.symbol_info.find({'status': {$type: 1}}).count() ## 批量修改字段类型 db.symbol_info.find({\"status\":{$type:1}}).forEach(function(x){x.status=NumberInt(x.status);db.symbol_info.save(x)}) 事务 https://www.jianshu.com/p/d838a5905303 索引 db.symbol_info.createIndex({'exchange': 1, 'symbol': 1}, {unique: true}) ","date":"2021-01-29","objectID":"/db-mongo-syntax/:1:0","tags":["mongo","数据库"],"title":"Mongo Note","uri":"/db-mongo-syntax/"},{"categories":["linux"],"content":"记录常用的Linux命令以及Shell语法 ","date":"2019-07-04","objectID":"/linux-shell/:0:0","tags":["shell"],"title":"常用Shell命令","uri":"/linux-shell/"},{"categories":["linux"],"content":"Shell 清屏 Ctrl + l 滚动文档 tail -f 刷新暂停：Ctrl + s 刷新继续：ctrl + q 挂起任务 Ctrl + z 用fg命令恢复 强制中断进程 Ctrl + c grep 反响过滤 -v #!/bin/bash grep \"api.coinw.me.*appApi.*action=trade\" tradingcenter_info.log | grep -v code.*200 输入输出重定向 command1 \u003e file1 # 上面这个命令执行command1然后将输出的内容存入file1。任何file1内的已经存在的内容将被新内容替代。 command1 \u003c file1 # 本来需要从键盘获取输入的命令会转移到文件读取内容。 更换文件所属用户 chown marspro marswebserver 更换文件所属用户组 chgrp marspro marswebserver ","date":"2019-07-04","objectID":"/linux-shell/:1:0","tags":["shell"],"title":"常用Shell命令","uri":"/linux-shell/"},{"categories":["linux"],"content":"tar 查看 // 在不解压的情况下查看压缩包的内容 tar -tf aaa.tar.gz 压缩 //将目录里所有jpg文件打包成tar.jpg tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar –czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z tar –cZf jpg.tar.Z *.jpg 解压 //解压 tar包 tar –xvf file.tar //解压tar.gz tar -xzvf file.tar.gz //解压 tar.bz2tar –xZvf file.tar.Z //解压tar.Z tar -xjvf file.tar.bz2 ","date":"2019-07-04","objectID":"/linux-shell/:1:1","tags":["shell"],"title":"常用Shell命令","uri":"/linux-shell/"},{"categories":["linux"],"content":"vim 显示行号 set nu 隐藏行号 set nonu 查找字符 /vol 上一个 N 下一个 n 删除整行 dd 撤回 u 刷新 e 删除行：光标所在处 dd 删除多行：光标以下N行 Ndd 复制 cp [文件] [目录] # 循环复制 cp -r [文件夹] [目录] 删除文件 rm -rf：递归的删除文件及子文件，不询问 查找文件 # 一定要注意path find \u003cpath\u003e \u003cexpression\u003e find / -name filename find / 启动jar包进程 退出后不关闭进程: java -jar tcjobs.jar binanceWsJob \u0026 查看进程 ps -ef | grep tcjobs.jar 重命名 \u0026 移动 mv A B：将A重命名为B mv a/b c/b：将b从a移动到c 上传/下载 rz -be：上传 sz：下载 统计行数 grep -c \"aaa\" bb.log grep aaa bb.log | wc -l 正则连续区间 grep -E '24[88-91].*bbb.*' bb.log 变量声明 declare 可以一次声明多个 用空格隔开 远程连接 ssh \u003cIP\u003e 截取字符串 echo ${var:0:5} 拼接字符串 $value1=home $value2=${value1}\"=\" echo $value2 IF if [ 条件表达式 ];then ... elif [ 条件表达式 ];then ... else ... fi # 条件表达式两边必须有空格 # 组合条件：-a:and -o:or !:非 # 整数判断：-gt/-lt/-ge/-le # 字符串判断：\u003e/\u003c/== 字符串转数字 value=$((n#${key}Xm)) # value:自定义变量得到运算的值 # n:欲转成的进制数； 2进制就是2，10进制就是10 # key:字符串变量 # X：操作符；如+ - * / \u0026... # m:操作数 while while [ condition ] do commands done 查看端口 netstat -lntp 定时任务 查看：crontab -l 编辑：crontab -e */30 * * * * rm -f /tmp/ds-persist.10-35-97-244.nf.log.* 如果多种情况，用“，”隔开 \u003c分时日月年 conmond\u003e 查看内存情况 top 查看剩余内存情况 free 通过PID查找文件目录 ll /proc/\u003cPID\u003e 查询时间区间内的行 cat aa.log bb.log | grep -E \"cc.*\" | sed -n '/1534953593/','/1534953604/p' 修改替换文本 sed -i 's/aa/bb/g' cc.log 退出高亮 :nohl 指定指令 alias 快捷键 = ' … ' alias -p 打印指令别名 输入其他命令 «EOF 告诉shell，后面的命令执行其他的命令，不作为主shell执行 EOF 知道遇到它为止 解压rar # centos安装rar方法 wget http://www.rarsoft.com/rar/rarlinux-x64-5.4.0.tar.gz tar -zxvf rarlinux-x64-5.4.0.tar.gz cd rar make rar x centos.rar # 解压 centos.rar 到当前目录 rar centos.rar ./piaoyi.org/ # 将 piaoyi.org 目录打包为 centos.rar 日期格式化 date ‘+%Y%m%d%H’ 查看进程启动数目 ps -ef | grep bitmexSymbolJob | grep -v “grep” | wc -l 监测java进程运行结果 $? 如果爆出异常 会返回1 如果完整执行完， 返回0 删除windows换行码 cat fcoin | tr -d \"\\015\" \u003e newfcoin 查看防火墙 service iptables stop service iptables status service iptables start /etc/sysconfig/iptables # 配置路径 # 或者 systemctl status iptables systemctl stop iptables 历史记录 history | grep \u003cregexp\u003e ","date":"2019-07-04","objectID":"/linux-shell/:1:2","tags":["shell"],"title":"常用Shell命令","uri":"/linux-shell/"},{"categories":["linux"],"content":"Python SHELL执行python 时， 传参如果是一个带空格的字符串，如果用$vol只能传递空格前的一个子串，加上“$vol”就可以了 安装mongodb python2.7 -m easy_install pymongo 抓包 tcpdump 获取几天之后的日期 date -d 7day +%Y%m%d 查找与替换 将第一行替换成just并保存 sed -i ‘1c just’ date.sh sed中传入参数 date=`date -d 7day +%Y%m%d` sed -i '1c '$date'' date.sh sed打印第一行 symbol=sed -n 'p' ../../util/symboldate 观察日志 tail -f nohup.out | egrep ‘ERROR|ception’ 查询出口IP curl ifconfig.me curl ipinfo.io 排查磁盘空间问题 df -h # 查看磁盘占用情况 du -sh * # 查看文件大小 查看文件情况 lsof # 查看已删除文件 lsof | grep deleted 记一次查询记录 grep huobicloud nohup.out.20190222 | grep handleMessage | grep order | awk -F'[:,]+' '{print $10\" \"$17\" \"$33}' grep huobicloud nohup.out.20190222 | grep handleMessage | grep partial-filled | awk -F':' '{print $12}' | sort | uniq | awk -F',' '{print $1}' \u003e order_id grep huobicloud nohup.out.20190222 | grep handleMessage | grep order | awk -F'[:,]+' '{print $17\" \"$10\" \"$33}' | sort last 查看登录信息 ","date":"2019-07-04","objectID":"/linux-shell/:1:3","tags":["shell"],"title":"常用Shell命令","uri":"/linux-shell/"},{"categories":["tool"],"content":"记录Git的常用命令 ","date":"2019-07-03","objectID":"/tools-git/:0:0","tags":["git"],"title":"Git常用命令","uri":"/tools-git/"},{"categories":["tool"],"content":"svn 版本回滚 svn revert -R . 版本比较 svn diff 比较两个目录 svn diff \u003c/path\u003e \u003c/path2\u003e svn diff svn://106.75.122.25/nextfintech/source/trading_center/prod/tradingcenter_parent svn://106.75.122.25/nextfintech/source/trading_center/trunk/tradingcenter_parent \u003e\u003e diff.txt grep Index diff.txt # 以上为修改的文件 ","date":"2019-07-03","objectID":"/tools-git/:0:1","tags":["git"],"title":"Git常用命令","uri":"/tools-git/"},{"categories":["tool"],"content":"git 创建本地仓库 git init git --help git add ./ git commit -m \"first commit\" git config --global user.email \"1014435409@qq.com\" git config --global user.name \"EmbraceUU\" git commit -m \"first commit\" git remote add origin https://github.com/EmbraceUU/go-commons.git git pull --rebase origin master git push -u origin master 删除远程库文件 git rm --cached -r .idea git commit -m 'delete .idea' git push origin master error error: Your local changes to the following files would be overwritten by merge: git reset --hard git pull origin master 回退commit版本 git log 查看日志 git reset --soft \u003c版本号\u003e 只回退commit, 不会修改index和缓冲区 ","date":"2019-07-03","objectID":"/tools-git/:0:2","tags":["git"],"title":"Git常用命令","uri":"/tools-git/"},{"categories":["database"],"content":"MySQL日常笔记, 包括了一些常用命令和语法. ","date":"2019-03-05","objectID":"/db-mysql-syntax/","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"MySql ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:0","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"登录 mysql -u username -p ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:1","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"执行SQL文件 source [path][filename] ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:2","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"定向输出到文件 开启：pager cat » [path][filename] 关闭：nopager ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:3","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"插入更新 insert … on duplicate key update … 当没有时insert，存在时update ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:4","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"时间函数 now() 返回SQL执行的时间 ，不是动态的当前时间 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:5","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"ibd文件 mysql中的ibd文件是数据文件和索引文件，无法直接读取 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:6","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"转换数据库 use \u003cdataBase\u003e ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:7","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"显示表 show tables ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:8","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"显示指定表的表结构 desc \u003ctablename\u003e ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:9","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"格式化显示 \\G ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:10","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"ContOS7 离线安装mysql 安装mysql ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:11","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"备份表结构和数据 mysqldump -h\\\u003cIP\u003e -u\\\u003cname\u003e -p\\\u003cpwd\u003e \\\u003cdbname\u003e \\\u003ctablename\u003e \u003e /root/trdSymbols.sql --where=\" exchange='aaa' 过滤条件 --extented-insert=false 分成多条 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:12","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"限制显示条数 select … limit n 显示n条 select … limit m n 从m+1条后面显示n条 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:13","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"generator --eclipse中生成：maven build ... -\u003e mybatis-generator:generate --注释乱码问题：xml文件中\u003ccommentGenerator\u003e里面添加\u003cproperty name=\"javaFileEncoding\" value=\"UTF-8\"/\u003e -\u003e exlipse.ini 文件，最末尾加上 -Dfile.encoding=UTF-8 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:14","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"隔离级别 隔离级别 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:15","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"replace into 识别同一条记录 URL ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:16","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"设置默认值 alter table trd_orders alter column margin drop default; (若本身存在默认值，则先删除) alter table trd_orders alter column margin set default '';(若本身不存在则可以直接设定) ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:17","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"查看建表语句 show create table table_name; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:18","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"更改线上数据库 begin; select count(*) from trd_orders where exchange \u003c\u003e 'BITMEX'; update trd_orders set SecurityType = 0 where exchange \u003c\u003e 'BITMEX'; commit; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:19","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"插入列 ALTER table `trd_symbols` ADD `position_currency` char(10) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '期货，持仓货币'; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:20","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"修改列类型 ALTER table \u003ctablename\u003e modify column \u003ccolumnname\u003e \u003ctype\u003e DEFAULT NULL COMMENT \u003ccomment\u003e; -- 正常，能修改字段类型、类型长度、默认值、注释 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:21","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"修改列默认值 alter table 表名 alter column 字段名 drop default; (若本身存在默认值，则先删除) alter table 表名 alter column 字段名 set default 默认值;(若本身不存在则可以直接设定) ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:22","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"增加唯一键索引 alter table trd_orders add UNIQUE index `un_cl_order_id` (`cl_ord_id`,`account_id`) USING HASH; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:23","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"替换字符串 replace(object, search,replace) ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:24","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"bash执行mysql -- 通过EOF mysql -h10.35.174.248 -uroot -pnextfintech@2018 tradingcenter \u003c\u003c EOF use tradingcenter source /root/symbolJob/sql/bitmex.sql; exit EOF -- 通过 -e mysql -h\u003cip\u003e -u\u003cusername\u003e -p\u003cpassword\u003e \u003cdbname\u003e -e \"sql语句\" \u003e\u003e \u003cpath\u003e\u003cfilename\u003e mysql -h10.35.174.248 -uroot -pnextfintech@2018 tradingcenter -e \"select count(*) from trd_orders where strategy_id = '410eacec-34f7-11e9-afbc-00ff38c49b16' and created_at \u003e '2019-02-25 12:00' and created_at \u003c '2019-02-26 12:00'\\G\" \u003e\u003e /home/sqlite ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:25","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"自增序列 auto_increment 可以在表的基本信息中查看 SELECT * FROM information_schema.tables WHERE table_name = \u003ctableName\u003e ; 如果为AUTO_INCREMENT字段明确指定了一个数值，则会出现两种情况 如果插入的值与已有的编号重复，则会出现出 错信息，因为AUTO_INCREMENT数据列的值必须是唯一的 如果插入的值大于已编号的值，则会把该插入到数据列中，并使在下一个编号将从这个新值开始递增 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:26","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"联合索引 --复合索引 \u003cemp_no, title, from_date\u003e select * from table where emp_no = '1' and title = 'aaa' and from_date = '1990' ; --全值匹配 select * from table where title = 'aaa'; --不遵循最左前缀, 不明中索引 select * from table where emp_no \u003e '1'; --命中索引, 范围查找. select * from table where emp_no \u003e '1' and title = 'aaa'; --emp_no命中索引, 但是范围查找, title不能走索引. select * from table where emp_no \u003e '1' order by title; --emp_no命中索引, 同样title不能走索引; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:27","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"其他数据结构 二叉树作为索引有可能会出现单边增长的情况. O(log2n) 红黑树会自平衡, 不会出现单边增长的情况. JDK1.8 的 hashmap 是用的红黑树. 数据量大的时候, 深度不可控. HASH 如果是定位到某一行,通过 hash 算法计算出地址,是很快, 不满足范围查找. ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:28","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"BTREE 度(Degree)是每个节点存储数据的最大个数 叶子节点具有相同的深度 叶子阶段的指针为空 叶子节点的数据从左到右顺序排列 每个节点内的顺序查找实在内存中查找, 几乎可以忽略不计 Degree 可以设计为磁盘一次I/O读取的数据数 BTREE 的每个节点中除了存储键值, 还有data数据, 但是如果一行的col太多, data也会很大, 也不适合. 所以引入了BTREE的变种 B+TREE. ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:29","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"B+TREE 非叶子节点不存储data, 之存储key , 在容量和表大小确定的情况下, 可以增大Degree, 减少深度, 也就减少 I/O 次数. B+ TREE的Degree一般会在100以上, h一般在3-5之间. 叶子节点增加了顺序访问指针, 提高范围查找性能. 不用返回上层,减少了I/O操作. 预读: 磁盘在一次 I/O 中, 会把要读取的数据相邻的局部数据一起存入内存, 并且是页的整倍数(4K). BTREE的一个节点的大小一般一会设置为4K.新建节点的时候会直接申请一页的内存, 使得一个节点在物理上也存储在一个页里面. ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:30","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"聚簇索引 叶子节点中将索引键值和data存放在一起. 会自动选择为主键. 非主键索引不是聚簇索引 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:31","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"存储引擎 是表级别 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:32","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"InnoDB 主键索引和非主键索引的存储结构不一样 数据文件本身就是索引文件, 主键聚簇索引, 内存不能全部存储一个索引文件, 所以会产生I/O, B+TREE结构可以减少I/O次数. Secondary key 不是聚簇索引, 但是叶子节点会存储Primary key 主键推荐是整型的自增序列, 因为InnoDB的存储结构, 是B+ TREE的索引文件, 自增整型检索速度比UUID要快, 并且影响二级索引的大小 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:33","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"索引策略 索引必须是独立的列, 不能用表达式或者函数的入参. 遵循最左前缀原则. 复合索引中, 范围查找影响索引.比如like和in还有\u003e\u003c这种. ","date":"2019-03-05","objectID":"/db-mysql-syntax/:1:34","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"Oracle ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:0","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"查看表空间 select tablespace_name, file_id, file_name,round(bytes/(1024*1024),0) total_space from dba_data_files order by tablespace_name; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:1","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"创建表空间 create tablespace hussar2 datafile 'G:\\hussar01.DBF' size 500M autoextend on next 100M maxsize unlimited ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:2","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"删除表空间 DROP TABLESPACE hussar2 INCLUDING CONTENTS AND DATAFILES; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:3","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"扩展表空间 ALTER TABLESPACE hussar2 add DATAFILE 'G:\\hussar02.DBF' size 500M AUTOEXTEND ON NEXT 100M MAXSIZE unlimited; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:4","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"计算100天之前的日期 select to_date('2017-06-01', 'yyyy-mm-dd') - 100 as time from dual; ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:5","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"case when 在检索列中的case when列，不能在where条件中直接用，可以用with as临时表将其提出来。 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:6","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"decode decode(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值)，相当于IF语句，用值和条件对比，替换成返回值。 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:7","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"instr instr（源字符串 , 目标字符串 ,开始位置,第几次出现） ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:8","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"递归查询 --树节点及其子节点 select \u003c检索列\u003e from \u003ctable\u003e where \u003ccondition\u003e START WITH \u003croot\u003e CONNECT BY \u003cconnect condition\u003e order by \u003csort\u003e 简单说来是将一个树状结构存储在一张表里，比如一个表中存在两个字段:code，parent_code，那么通过表示每一条记录的parent是谁，就可以形成一个树状结构，用上述语法的查询可以取得这棵树的所有记录，其中: 条件1 是根结点的限定语句，当然可以放宽限定条件，以取得多个根结点，实际就是多棵树。 条件2 是连接条件，其中用PRIOR表示上一条记录，比如 CONNECT BY PRIOR code = parent_code；就是说上一条记录的code 是本条记录的parent_code，即本记录的父亲是上一条记录。 条件3 是过滤条件，用于对返回的所有记录进行过滤。 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:2:9","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"DB2 locate(arg1,arg2,\u003cpos\u003e) -- 查找arg2中第一次出现arg1的位置，指定pos，则从arg2的pos处开始找arg1第一次出现的位置 -- 0:未找到arg1 -- 1:在第一个 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:0","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"order by n 按照第n个栏位排序 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:1","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"days 比较两个日期的大小，用days()可以做比较， ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:2","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"1 MONTH + 10 DAYS 下个月的今天的十天以后，可以直接在日期后面加上。 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:3","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"NOT IN 对于在某个范围内的，用 in (select…) ，如果是他的余集，可以用 NOT IN (select …)，即不在这个范围内的结果集。 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:4","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"IN 当用到in的时候，不得不说到从前面向后面传ID字符串来直接放在in里面，但是不能直接在字符串后面拼接“，”或者下一个ID，应该这样：id_hbzl = id_hbzl +\"','\"+ ress[‘id’];然后在后台接受的时候，也要用'‘单引号包起来。 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:5","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"重组表结构 call admin_cmd('reorg table ENVIR.T_ATTACHFILE_SERVICE_XKZ_HB2'); ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:6","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"CAST 是一个转换格式的函数，具体用法为：cast(el as type); ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:7","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"with \u003ctemptablename\u003e as () 将要查询的内容组成一个临时表，在SQL中后面的select,update,delete中用到。 可以重复利用，尤其像UNION ALL这种查询中，可以将重复的的查询提出来。 有时候，会需要一些聚合函数会碰到group by分组的情况，如果一味的left join会使得其他的表格查的很不方便。 后面可以定义多个临时表，用逗号分开，最后一个不用。 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:8","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"问题1 --库中查出两个用逗号连载一块的字符串id，要显示成汉字value，但是字典表中是一对一的。 SELECT ( SELECT REPLACE(REPLACE(XML2CLOB(XMLAGG(XMLELEMENT(NAME A, REMARK||','))),'\u003cA\u003e',''),'\u003c/A\u003e','') FROM PLATFORM.DICT WHERE PARENT_ID IN ( SELECT ID FROM PLATFORM.DICT WHERE NAME = 'FILTER_TYPE') AND LOCATE( ''''||NAME||'''' , ''''||REPLACE(GSCCJLX,',',''',''')||'''') \u003e 0) GSCCJLX FROM ENVIR.T_ZDL_UNIT_INDVAL ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:9","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"LEFT(ARG,LENGTH)、RIGHT(ARG,LENGTH) 返回ARG字符串的左边、右边length长度的子字符串 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:10","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"NVL(ARG,0) 返回arg，如果arg为null，返回0 ","date":"2019-03-05","objectID":"/db-mysql-syntax/:3:11","tags":["mysql","数据库"],"title":"Mysql 相关汇总","uri":"/db-mysql-syntax/"},{"categories":["database"],"content":"记录一次Mongo的慢查询分析以及索引优化过程. ","date":"2019-03-05","objectID":"/db-mongo-explain/:0:0","tags":["mongo","数据库"],"title":"记一次Mongo的优化过程","uri":"/db-mongo-explain/"},{"categories":["database"],"content":"问题描述 db.coll.find({‘symbol’:{$in:[‘OKEX.eth_btc’,‘OKEX.btc_usdt’]}}).explain(‘executionStats’) 查询耗时 “executionTimeMillisEstimate” : 6755 为6s, 需要添加索引, 减少全表扫描 因为查询需求需要按照多个字段过滤, 避免多个字段导致在FETCH阶段耗时太多, 所以选用复合索引 首先在测试环境尝试, 再在生产环境中添加 首先需要弄清楚mongo索引的特性: mongo的索引也是使用Btree作为数据结构, 并且复合索引也需要遵照最左前缀规则[从索引组合的最左边的字段开始排序, 如果查询中没有第一个左边的字段, 将不会走索引] ","date":"2019-03-05","objectID":"/db-mongo-explain/:0:1","tags":["mongo","数据库"],"title":"记一次Mongo的优化过程","uri":"/db-mongo-explain/"},{"categories":["database"],"content":"测试过程 简历索引: db.trade_report.createIndex({‘symbol’:1,‘account_id’:1},{background: true}) 查询耗时: db.trade_report.find({‘symbol’:{$in:[‘OKEX.eth_btc’,‘OKEX.btc_usdt’]}}).explain(‘executionStats’) 可以看到, FETCH阶段不到0ms, IXSCAN阶段不到0ms; $in查询走索引 因为用到了5个字段, 所以删除当前索引, 使用多个字段测试 db.trade_report.dropIndex(‘symbol_1_account_id_1’) accountId是必须的参数, cl_order_id和exec_type是选用的参数, 还有strategy_id和symbol参数 创建5个字段的索引 db.trade_report.createIndex({‘account_id’:1,‘exec_type’:1,‘cl_order_id’:1,‘strategy_id’:1,‘symbol’:1},{background: true}) db.trade_report.find({‘account_id’:‘7675E0D483211CCD2184CA1CB9B3B8AB’}).explain() 走索引了 db.trade_report.find({‘account_id’:‘7675E0D483211CCD2184CA1CB9B3B8AB’,‘symbol’:‘BINANCE.BTCUSDT’}).explain() 竟然也走索引了. 颠倒顺序: db.trade_report.find({‘account_id’:‘7675E0D483211CCD2184CA1CB9B3B8AB’,‘symbol’:‘BINANCE.BTCUSDT’,‘cl_order_id’:‘0e2691d6-8eef-11e8-960c-00163e0c0cdf’}).explain() mongo在查询之前重新调整and顺序, 依旧走索引了. 去掉最左边的account_id字段, db.trade_report.find({‘symbol’:‘BINANCE.BTCUSDT’,‘cl_order_id’:‘0e2691d6-8eef-11e8-960c-00163e0c0cdf’}).explain(), stage为COLLSCAN, 没有走索引 不能只简单的给mongo建索引, 还需要从业务层面考虑如何建立, 比如对cl_order_id这种字段建立索引是没有必要的, 他还是需要扫描很多数据 而且 如果字段比索引多了还走索引吗 ? 在遵循最左前缀原则外, 另外加了side字段作为过滤 db.trade_report.find({‘account_id’:‘D78B9B2D60E8A34504EE6AB3DCD13357-00003’,‘strategy_id’:‘5a29eb73-39ad-11e9-99c8-00ff85a0533d’,‘side’:‘3’}).explain() explain results: Each stage passes its results (i.e. documents or index keys) to the parent node. The leaf nodes access the collection or the indices. The internal nodes manipulate the documents or the index keys that result from the child nodes. The root node is the final stage from which MongoDB derives the result set. 子阶段返回结果给父阶段, 先开始IXSCAN, 再进行FETCH阶段 如果查询可以命中索引，它就可以直接给出满足条件的所有文档的地址（IXSCAN），由于得到的是地址，不是文档本身，所以还需要一个额外的步骤从地址找出实际的文档（FETCH）； explain.executionStats.executionTimeMillis: Total time in milliseconds required for query plan selection and query execution. advanced: The number of intermediate results returned, or advanced, by this stage to its parent stage. 返回或者推到父阶段的结果 排序的字段顺序需要考虑索引的顺序 添加索引示例 db.trade_report.createIndex({‘exec_id’:-1},{background:true,sparse:true}) 此为单一字段的索引, background为后台运行,不阻塞mongo的其他操作, sparse为在索引字段存在的时候 才会有添加索引的动作,节省资源 区间查询是否走索引 db.trade_report.createIndex({‘create_at’:-1},{background:true}) db.trade_report.find({‘create_at’:{$gte:‘2019-03-02 00:00:00’,$lte:‘2019-03-02 23:59:59’}}).explain(‘executionStats’) 测试开始: 当前集合拥有的索引有: 命令为: db.trade_report.find({‘account_id’:‘D78B9B2D60E8A34504EE6AB3DCD13357-00003’,‘strategy_id’:‘f3b98546-3c98-11e9-8d1d-00ff85a0533d’,‘create_at’:{$gte:‘2019-03-02 00:00:00’,$lte:‘2019-03-02 23:59:59’}}).explain(‘executionStats’) winner plan: 这是理想状态下的, 索引检索返回来的结果和filter中非索引字段过滤的结果一致 命令行: db.trade_report.find({‘account_id’:‘D78B9B2D60E8A34504EE6AB3DCD13357-00003’,‘strategy_id’:‘f3b98546-3c98-11e9-8d1d-00ff85a0533d’,‘create_at’:{$gte:‘2019-03-02 19:41:14’,$lte:‘2019-03-02 19:41:15’}}).explain(‘executionStats’) winner plan : mongo 选用了create_at索引 , 没有走account_id_1_strategy_id_1_symbol_1索引 需要考虑索引的大小, 因为索引也是占用空间的, 太大了就没有意义了, 反而浪费资源 从数据出发，基于真实场景的日志，把业务体系里常见的查询滤出来，对最常见的查询做针对性的索引优化，然后对非常不常见的查询组合，从源头是可以控制的。 根据where条件建索引是极其重要的一个原则; 注意不要过多用索引,否则对表更新的效率有很大的影响,因为在操作表的时候要化大量时间花在创建索引中 The $match and $sort pipeline operators can take advantage of an index when they occur at the beginning of the pipeline. 聚合查询中的$match是走索引的, 需要把$match最前面的, 进入管道的数据会少很多, 并且把$sort放在$match后面会减少一部分的排序 聚合查询使用explain: db.col.aggregate(pepiline, options) db.trade_report.aggregate([{$group:{_id:'$account_id',count:{$sum:1}}}],{explain:true}) 查询当前accountid一共有多少: db.trade_report.aggregate([{$group:{_id:'$account_id',count:{$sum:1}}},{$group:{_id:'$account_id',num:{$sum:1}}}]) 并且account对应的数据量大小也相差较多, 少的有1个 大的有几万 命令行: db.trade_report.find({‘account_id’:‘CE1406597976E3EF15793403649346B6’}).explain(‘executionStats’) 命令行: db.trade_report.find({‘account_id’:‘CE1406597976E3EF15793403649346B6’,‘strategy_id’:‘7ab8d8dd-3a6f-11e9-acd2-0e04d673df9e’}).limit(1).explain(‘executionStats’) 因为业务上每次都会有accountid和strat","date":"2019-03-05","objectID":"/db-mongo-explain/:0:2","tags":["mongo","数据库"],"title":"记一次Mongo的优化过程","uri":"/db-mongo-explain/"},{"categories":["java"],"content":"记录Log4j在项目中的配置范本. 下面是properties的配置 log4j.rootLogger=info,console, D, Elog4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.Threshold=DEBUGlog4j.appender.console.Target=System.outlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%-5p][%d][%t][%l][logid(%X{request.logid})][uri(%X{request.uri})]: %m %x %nlog4j.appender.console.Encoding=UTF-8log4j.appender.D=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.layout=org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern=[%-5p][%d][%t][%l][logid(%X{request.logid})][uri(%X{request.uri})]: %m %x %nlog4j.appender.D.DatePattern='.'yyyyMMddlog4j.appender.D.Threshold = DEBUGlog4j.appender.D.File=./logs/info/tc.loglog4j.appender.D.Encoding=UTF-8log4j.appender.E=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.layout=org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern=[%-5p][%d][%t][%l][logid(%X{request.logid})][uri(%X{request.uri})]: %m %x %nlog4j.appender.E.DatePattern='.'yyyyMMddlog4j.appender.E.Threshold = DEBUGlog4j.appender.E.File=./logs/error/tc.loglog4j.appender.E.Encoding=UTF-8 JAVA中给某个线程配置Log RuntimeMXBean rt = ManagementFactory.getRuntimeMXBean(); String pid = rt.getName(); MDC.put(LOG_REQUEST_LOGID, Thread.currentThread().getId()); MDC.put(LOG_REQUEST_PID, pid); ","date":"2018-12-24","objectID":"/java-log4j-conf/:0:0","tags":["java","log4j"],"title":"记录Log4j的配置范本","uri":"/java-log4j-conf/"},{"categories":["database"],"content":"记录一些MySQL在Linux环境中的运维是可能用到的命令. ","date":"2018-12-19","objectID":"/db-mysql-shell/:0:0","tags":["mysql","数据库"],"title":"MySQL Shell 常规命令汇总","uri":"/db-mysql-shell/"},{"categories":["database"],"content":"使用sh脚本操作MySQL ","date":"2018-12-19","objectID":"/db-mysql-shell/:1:0","tags":["mysql","数据库"],"title":"MySQL Shell 常规命令汇总","uri":"/db-mysql-shell/"},{"categories":["database"],"content":"一般性操作 包括数据库的创建以及数据库表的操作 #!/bin/bash HOSTNAME=\"127.0.0.1\" PORT=\"3306\" USERNAME=\"root\" PASSWORD=\"\" DBNAME=\"test_db\" TABLENAME=\"test_table\" #创建数据库 create_db_sql=\"create database IF NOT EXISTS ${DBNAME}\" mysq l -h${HOSTNAME} -P${PORT} -u${USERNAME} -p${PASSWORD} -e\"${create_db_sql}\" #创建表 create_table_sql=\"create table IF NOT EXISTS ${TABLENAME}( name varchar(20), id int(11) default 0 )\" mysql -h${HOSTNAME} -P${PORT} -u${USERNAME} -p${PASSWORD} ${DBNAME} -e\"${create_table_sql}\" #插入数据 insert_sql=\"insert into ${TABLENAME}values('billchen',2)\" mysql -h${HOSTNAME} -P${PORT} -u${USERNAME} -p${PASSWORD} ${DBNAME} -e\"${insert_sql}\" #查询 select_sql=\"select * from ${TABLENAME}\" mysql -h${HOSTNAME} -P${PORT} -u${USERNAME} -p${PASSWORD} ${DBNAME} -e\"${select_sql}\" #更新数据 update_sql=\"update ${TABLENAME}set id=3\" mysql -h${HOSTNAME} -P${PORT} -u${USERNAME} -p${PASSWORD} ${DBNAME} -e\"${update_sql}\" mysql -h${HOSTNAME} -P${PORT} -u${USERNAME} -p${PASSWORD} ${DBNAME} -e\"${select_sql}\" #删除数据 delete_sql=\"delete from ${TABLENAME}\" mysql -h${HOSTNAME} -P${PORT} -u${USERNAME} -p${PASSWORD} ${DBNAME} -e\"${delete_sql}\" mysql -h${HOSTNAME} -P${PORT} -u${USERNAME} -p${PASSWORD} ${DBNAME} -e\"${select_sql}\" ","date":"2018-12-19","objectID":"/db-mysql-shell/:1:1","tags":["mysql","数据库"],"title":"MySQL Shell 常规命令汇总","uri":"/db-mysql-shell/"},{"categories":["database"],"content":"特殊操作 shell中的data作为参数, 执行MySQL语句 #!/bin/bash # get new order createdtime now=`date -d'-2 minutes' '+%G-%m-%d %H:%M:%S'` # mysql命令 orderTime=$(mysql -h127.0.0.1 -uroot test -e \"select count(*) from tablename where created_at \u003e '${now}';\") # 执行mysql命令 echo $orderTime # 获取结果 arr=(${orderTime}) # 进行结果处理 echo ${arr[1]} if [ ${arr[1]} -gt 0 ];then echo YES else echo NO fi # check time with now now=`date '+%G-%m-%d %H:%M:%S'` echo $ expr '(' $orderTime - $now ')' ","date":"2018-12-19","objectID":"/db-mysql-shell/:1:2","tags":["mysql","数据库"],"title":"MySQL Shell 常规命令汇总","uri":"/db-mysql-shell/"},{"categories":["java"],"content":"记录java中常见的知识点 ","date":"2017-11-23","objectID":"/java-syntax/:0:0","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"接口 java接口不能被实例化，但是可以被实现，要实现接口，必须实现接口中多有的方法，否则就要声明为抽象类。 ","date":"2017-11-23","objectID":"/java-syntax/:0:1","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"多线程的实现 java内置了多线程的支持，一个进程包含了多个线程，每条线程并行执行不同的任务。 1.实现Runnable接口，实现run()方法，并且new一个Thread对象，执行start()方法。run()方法中是此线程执行的方法体。 2.继承Tread类，重写run()方法，实例化Tread对象后，执行start()方法，run()方法中是此线程执行的方法体。 3.wait()，notify()不是Thread的方法，而是Object基础类的方法，因为每个对象都有锁，这两个方法是操作锁的方法， wait()方法的使用必须放在synchronized(obj)代码中，而且要放在while循环里面而不是if条件里面 ","date":"2017-11-23","objectID":"/java-syntax/:0:2","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"面向对象的特征 1.封装：将属性和方法封装在一个类中，属性一般用private，用public修饰的get/set方法实现取值和赋值，这样将细节隐藏，只提供接口给外界操作。 2.继承：面向对象的显著特征，JAVA是单继承，在父类中定义的属性和方法适用于其本身以及每一层子类的全部对象。减小代码的冗余度，增加复用性，子类只需要定义特殊的属性和方法即可。 3.多态：【重载】通过修改参数的数量、修改参数的数据类型实现方法的重载，方法的重载增加了程序的可读性。【重写】子类继承父类时，名字相同，参数相同的方法为重写的方法。【不能覆盖静态方法】因为静态方法是绑定的类，静态方法属于类区域，实例方法属于堆区域 ","date":"2017-11-23","objectID":"/java-syntax/:0:3","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"final finally finalize的区别 final可以声明属性、方法和类，分别表示：属性不可变、方法不可覆盖、类不可继承 finally是异常处理语句中的一部分，表示总是执行 finalize是Object类的方法，是垃圾收集器将对象从内存中清楚之前对此对象调用的，做清理工作。 ","date":"2017-11-23","objectID":"/java-syntax/:0:4","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"JVM java代码编译由java源码编译器完成 java字节码的执行由JVM执行引擎完成 过程包含三个机制： java源码编译机制 类加载机制 类执行机制 JVM包括： 栈：运行时方法 堆：创建的对象 本地方法栈：native方法存放 方法区：加载的类、final变量、静态变量、属性等 ","date":"2017-11-23","objectID":"/java-syntax/:0:5","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"JNI java native Interface 实现了java和本地代码的交互，Java可以通过JNI访问操作系统底层 ","date":"2017-11-23","objectID":"/java-syntax/:0:6","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Native JDK中有一部分方法是用native修饰的，是用来访问本地方法的，这些本地方法不是java实现，但是java可以直接拿来用 public native static void Hello(); ","date":"2017-11-23","objectID":"/java-syntax/:0:7","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"分布式系统架构思路 水平扩展 负载均衡 垂直拆分 ","date":"2017-11-23","objectID":"/java-syntax/:0:8","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Stream jdk 1.8中增加了Lambda表达式，让行为表达为数据变得更容易，使得开发具有更强大的表达能力。 Lambda表达式还引进了双冒号的引用，引用的是方法，不是一个属性 list.forEach(n -\u003e System.out.println(n)); list.forEach(System.out::println); Stream有助于，为各种数据来源，可能的并行批量操作，建立简明的，声明性的表达式。 让开发者更加注重要\"做什么\"，具体怎么做，交给库的开发者。 ","date":"2017-11-23","objectID":"/java-syntax/:0:9","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"static 泛型，在使用泛型前，进入集合的元素可以是任何类型，但当从集合中取出，所有类型都是Object类型的，需要进行向下的强制类型转换。 ","date":"2017-11-23","objectID":"/java-syntax/:0:10","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Freemarker 是一个模板引擎，用java编写，用来生成web html文件 由Template HTML文件和Java Objects文件，通过Freemarker生成最终的HTML文件 可以通过mail发送，可以保存到本地文件，可以通过Web返回给浏览器 适用于MVC架构，可以脱离servlet，代替jsp作为视图层，实现前后端工作的分离互不干扰 jsp文件在编译以后会占用PermGen空间，而Freemarker不会。 ","date":"2017-11-23","objectID":"/java-syntax/:0:11","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"JBoss ","date":"2017-11-23","objectID":"/java-syntax/:0:12","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"String和StringBuilder\\StringBuffer String用+运算符连接字符串和StringBuffer用append()方法连接的方式，如果是直接连接没有区别，编译之后都是用StringBuilder的方法，但是如果在循环结构中，就不同了，如果用String的+，循环体中会重复创建StringBuilder对象，而垃圾回收不及时的时候，会占用大量内存。 ","date":"2017-11-23","objectID":"/java-syntax/:0:13","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"hibernate的merge()方法 新new一个对象， 如果该对象设置了ID，则这个对象就当作游离态处理： 当ID在数据库中不能找到时，用update的话肯定会报异常，然而用merge的话，就会insert。 当ID在数据库中能找到的时候，update与merge的执行效果都是更新数据，发出update语句； 如果没有设置ID的话，则这个对象就当作瞬态处理： 用update的话，由于没有ID，所以会报异常，merge此时则会保存数据，根据ID生产策略生成一条数据； ","date":"2017-11-23","objectID":"/java-syntax/:0:14","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"线程安全 线程安全是多线程访问同一代码，不会产生不确定的结果。 编写线程安全的代码需要依靠线程同步。 线程安全会涉及到synchronized，同一段代码只能有一个线程来操作。 Collections工具类中提供了synchronizedSet、synchronizedSortedSet、synchronizedList、synchronizedMap、synchronizedSortedMap方法，返回对应的同步对象，解决多线程并发访问集合时的线程安全问题。 ","date":"2017-11-23","objectID":"/java-syntax/:0:15","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Struts和Spring框架整合 StrutsAction管理委托给Spring框架，使用代理Action ","date":"2017-11-23","objectID":"/java-syntax/:0:16","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"POST和GET的区别 1.GET是从服务器上获取资源，POST是向服务器提交资源 2.GET传递参数是以name=value的形式，拼接在URL后面，用?开始拼接，后面用\u0026连接各个参数，会显示在URL中，不安全；POST是将表单中的信息，放在请求头或者消息体中，安全而且可以大量传输。 ","date":"2017-11-23","objectID":"/java-syntax/:0:17","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"向上转型 之前一直没有理解向上转型，今天碰到了Queue和LinkedList的时候，发现之前对这个概念的理解有出入。LinkedList实现了Queue接口，当一个对象是Queue的引用但是指向LinkedList的时候，只可以调用LinkedList类中实现的Queue的方法，LinkedList中自己的方法，该对象无法调用。 ","date":"2017-11-23","objectID":"/java-syntax/:0:18","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"接口回调 在了解向上转型的时候，发现了接口调用这个概念，继续用Queue和LinkedList做解释。如果一个对象用Queue引用，指向了LinkedList类，那么该对象可以调用被LinkedList实现的Queue的方法。 ","date":"2017-11-23","objectID":"/java-syntax/:0:19","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"import 之前没有注意过import引用，今天发现同一个pakage下的类调用其他类不用import，尝试了一下调用其他pakage中的类，发现报了编译错误，需要用import引用一下。 ","date":"2017-11-23","objectID":"/java-syntax/:0:20","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Queue\\LinkedList Queue继承Collection接口，LinkedList实现了它。支持FIFO，尾部添加，头部删除。 添加:offer()，添加失败返回false 删除:poll()，删除失败返回null 获取:peek()，获取失败返回null ","date":"2017-11-23","objectID":"/java-syntax/:0:21","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Vector\\Stack Vector继承Collection接口，Stack继承了Vector，支持LIFO，栈顶添加，栈顶删除。 push()，添加元素 pop( )，移除栈顶对象，返回该对象 peek( )，返回栈顶对象 ","date":"2017-11-23","objectID":"/java-syntax/:0:22","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"判断文件是否存在 File f = new File(path); //path是全路径 boolean flag = f.exists(); ","date":"2017-11-23","objectID":"/java-syntax/:0:23","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"得到文件列表 File[] files = file.listFiles(); // 可以根据名字中的子字符串去过滤文件并对其进行操作 for(File f : files){ // 获取到文件名 if(f.getName().indexOf(biz) != -1){ f.delete(); } } ","date":"2017-11-23","objectID":"/java-syntax/:0:24","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"获取绝对路径 request.getSession().getServletContext().getRealPath(虚拟path) // 但是这个方法被遗弃了，因为打包之后war包中没有目录结构，现改为 this.getClass().getClassLoader().getResource(\"/\").getPath(); // 此处为classes目录, 往上一层可以用 getResource(\"/../\")， // 直接指向文件名getResource(\"/../xxx.xxx\") ","date":"2017-11-23","objectID":"/java-syntax/:0:25","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"获取REQUEST信息 // JSP： http://localhost:8080/dmsd-itoo-exam-log-web/course/index.jsp // 工程名：/dmsd-itoo-exam-log-web request.getContextPath()：// 得到工程名：/dmsd-itoo-exam-log-web； request.getServletPath()：// 返回当前页面所在目录下全名称：/course/index.jsp； request.getRequestURL()：// 返回IE地址栏地址：http://localhost:8080/dmsd-itoo-exam-log-web/course/index.jsp； request.getRequestURI() ：// 返回包含工程名的当前页面全路径：/dmsd-itoo-exam-log-web/course/index.jsp。 ","date":"2017-11-23","objectID":"/java-syntax/:0:26","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"获取文件的后缀 String subfix = path.substring(path.lastIndexOf(\".\"), path.length()); ","date":"2017-11-23","objectID":"/java-syntax/:0:27","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"重定向 response.sendRedirect(); ","date":"2017-11-23","objectID":"/java-syntax/:0:28","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"布尔型转字符串 String s = String.valueOf( flag ); ","date":"2017-11-23","objectID":"/java-syntax/:0:29","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"String.getBytes() 根据指定的decode编码返回某字符串在该编码下的byte数组表示 byte[] b_gbk = \"中\".getBytes(\"GBK\"); byte[] b_utf8 = \"中\".getBytes(\"UTF-8\"); byte[] b_iso88591 = \"中\".getBytes(\"ISO8859-1\"); // b_gbk的长度为2，b_utf8的长度为3，b_iso88591的长度为1。 byte[] b = filename.getBytes(\"GBK\"); filename = new String(b, \"8859_1\"); ","date":"2017-11-23","objectID":"/java-syntax/:0:30","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Runtime类 Runtime类封装了运行时的环境。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。 一般不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前Runtime运行时对象的引用。 一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为. 当Applet和其他不被信任的代码调用任何Runtime方法时，常常会引起SecurityException异常。 ","date":"2017-11-23","objectID":"/java-syntax/:0:31","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"exec(String command) Process p = r.exec(command); // 在单独的进程中执行指定的字符串命令。 // ecec()方法返回一个Process对象，可以使用这个对象控制Java程序与新运行的进程进行交互。 ","date":"2017-11-23","objectID":"/java-syntax/:0:32","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"判断中文 通过Character.UnicodeBlock.of(String word)，返回一个Character.UnicodeBlock对象，看是否在中文对应的集合中 ","date":"2017-11-23","objectID":"/java-syntax/:0:33","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"JOSN返回数据案例 // 定义map Map map = new HashMap(); // 定义list List imgList = new ArrayList(); // 遍历数据 for(int i=0;i\u003cdata.size();i++){ StationImage stationImage = (StationImage)data.get(i); // 将当前对象放入map中 Map imgMap = new HashMap(); imgMap.put(\"image_name\", stationImage.getImage_name()); imgMap.put(\"image_des\", stationImage.getImage_des()); imgMap.put(\"image_url\", stationImage.getImage_url()); // 将当前Map放入list imgList.add(imgMap); } // 将list放入map map.put(\"imgInfo\", imgList); JSONObject jb = JSONObject.fromObject(map, jsonConfig); String result = jb.toString(); PrintWriter out = getOut(response); out.print(result); ","date":"2017-11-23","objectID":"/java-syntax/:0:34","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"shutdownHook Runtime.getRuntime().addShutdownHook(shutdownHook); 在jvm中增加一个关闭的钩子，在JVM关闭的之前，会先执行所有通过addShutdownHook添加的钩子，可以进行内存清理和对象销毁。 ","date":"2017-11-23","objectID":"/java-syntax/:0:35","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Assert junit中的Assert是断言，可以判断isNull isEmpty isTrue isFalse等。 eclipse中可以开启断言 assert [boolean 表达式] 如果为true 程序继续执行 如果为false 则抛出AssertionException异常 并终止执行 ","date":"2017-11-23","objectID":"/java-syntax/:0:36","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"String… 参数长度可变 从0到n 当大于一时相当于String[] ","date":"2017-11-23","objectID":"/java-syntax/:0:37","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"Timer和TimerTask Timer是一个jdk提供的定时器工具，可以在主线程之外单独执行指定任务 TimerTask是一个被Timer执行的任务 timer.schedule (task, time) 在指定时间执行一次 timer.schedule (task, firstTime，period) 在首次时间执行一次，后面每隔period时间执行一次 ","date":"2017-11-23","objectID":"/java-syntax/:0:38","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"加密方式 对称加密 + key ","date":"2017-11-23","objectID":"/java-syntax/:0:39","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"linux安装jdk yum search java|grep jdk ","date":"2017-11-23","objectID":"/java-syntax/:0:40","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"WebSocket连接频率控制 使用List ，用时间戳标记每次连接的时间，在channelInactive里面控制是否重新连接。 检查List超时的时间戳，超时的删除。 ","date":"2017-11-23","objectID":"/java-syntax/:0:41","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"HashMap 返回Key的value，如果没有返回默认值 getOrDefault(Key, defaultValue) ","date":"2017-11-23","objectID":"/java-syntax/:0:42","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"JSON解析 解析json时碰到了问题，当json格式为{‘key’:[‘aaa’,‘bbb’]}这种时，使用net.sf.json中的JSONObject解析不出来，使用fastjosn可以解析 但是解析出来的object中如果有的key的value为null时，containsKey返回值是true，使用时又是null，这样会报空指针异常，改用getOrDefault方法 ","date":"2017-11-23","objectID":"/java-syntax/:0:43","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"com.google.protobuf.Timestamp 和 java.util.Date相互转换 Timestamps.fromMillis(date.getTime()); new Date(timestamp.getSeconds() * 1000); ","date":"2017-11-23","objectID":"/java-syntax/:0:44","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"split()正则表达式 String time = \"2016-10-03T12:00:00.000Z\"; String[] timeArr = time.split(\"T|\\\\.\"); ","date":"2017-11-23","objectID":"/java-syntax/:0:45","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"matches正则表达式 String content = \"Canceled: Canceled via API.\\nSubmitted via API\"; String pattern = \".*Canceled.*via.*API[\\\\s\\\\S]*Submitted.*\"; System.out.println(Pattern.matches(pattern, content)); // 注意\\n用.匹配不到，需要用[\\\\s\\\\S] ","date":"2017-11-23","objectID":"/java-syntax/:0:46","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"javah 生成头文件 javah [] javah com.nd.job.Animal 生成的头文件中函数的命名规则：Java_包名_类名_方法名，由于要用到包名，所以要在包括全包名的目录下执行javah命令。 ","date":"2017-11-23","objectID":"/java-syntax/:0:47","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"加密通讯 ","date":"2017-11-23","objectID":"/java-syntax/:0:48","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"URI拼接参数 https://www.jianshu.com/p/3d1d4becbc31 ","date":"2017-11-23","objectID":"/java-syntax/:0:49","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"fastJson反序列化 https://my.oschina.net/u/566591/blog/664617 https://www.cnblogs.com/liqipeng/p/9148545.html ","date":"2017-11-23","objectID":"/java-syntax/:0:50","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"字符串\u0026JSON处理 当需要json格式的字符串时，可以先用json对象处理数据，最后用json转成string，避免了拼接和转义的处理 String[] argss = new String[]{\"swap/order:BTC-USD-SWAP\",\"swap/order:EOS-USD-SWAP\"}; JSONObject obj = new JSONObject(); obj.put(\"op\", \"subscribe\"); obj.put(\"args\", argss); System.out.println(JSON.toJSONString(obj)); ","date":"2017-11-23","objectID":"/java-syntax/:0:51","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"list的remove应该使用iterator, 不能使用foreach删除 ","date":"2017-11-23","objectID":"/java-syntax/:0:52","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"hashmap rehash 的过程 ","date":"2017-11-23","objectID":"/java-syntax/:0:53","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"hashmap 和 currenthashmap 的区别, 以及为什么 ","date":"2017-11-23","objectID":"/java-syntax/:0:54","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"treeMap 的实现 ","date":"2017-11-23","objectID":"/java-syntax/:0:55","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["java"],"content":"quickSort \u0026 binarySearch \u0026 红黑树 \u0026","date":"2017-11-23","objectID":"/java-syntax/:0:56","tags":["java"],"title":"Java 知识点整理","uri":"/java-syntax/"},{"categories":["questions"],"content":"记录平时遇到的问题 ","date":"2017-01-01","objectID":"/questions-note/:0:0","tags":["问题"],"title":"问题记录","uri":"/questions-note/"},{"categories":["questions"],"content":"订单队列pop出订单后，没有往下执行 下单被pending，一直代报 状态是placeOrderTask 线程pending了，拿不到redis 连接，涉及知识点，如何查看进程状态，jstack，以及redis pool的东西。 成交回报连接成功之后，又重新连接，并且timer没有cancel 因为没有keepAlive线程 主线程死了 没有cacell timer ","date":"2017-01-01","objectID":"/questions-note/:0:1","tags":["问题"],"title":"问题记录","uri":"/questions-note/"},{"categories":["questions"],"content":"Redis连接池连接波动 redis连接池连接波动问题，通过设置maxIdle 跟maxActive一致就可以，之前是20，40，那么行情一来，变成40，过一会行情少了，变成20了，然后又过来又变成40了，大小的话可以通过测试环境调，可以设定一个比较大的值，看最后稳定的大小。比如bitfinx设置的最大256，最后池子大小132左右。当然对于153 所有的所都连这个，需要各个所平衡。太多的连接也会影响到性能。类似的问题同样适应于mysql ","date":"2017-01-01","objectID":"/questions-note/:0:2","tags":["问题"],"title":"问题记录","uri":"/questions-note/"},{"categories":null,"content":"大家好, 我是达尼. 我现在的工作, 是区块链相关的 Golang 服务端开发工程师. 这个小站里会有我的一些日常整理, 学习总结, 个人杂谈等. 感谢你的到来, 谢谢! ","date":"2016-06-18","objectID":"/about/:0:0","tags":null,"title":"自我介绍","uri":"/about/"}]